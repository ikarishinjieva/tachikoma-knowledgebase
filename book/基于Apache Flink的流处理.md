- [17] 提及了 数据流处理技术 的发展路径
	- 第一代: 通过牺牲结果的准确性, 来换取低延迟 (对Lambda架构做出了介绍)
	- 第二代: 提供了更加完善的故障处理机制
	- 第三代: 解决了结果对事件到来事件及顺序的依赖问题. 也无需让用户在延迟和吞吐之间做出选择, 可兼顾二者

- [19] Flink的特点列表

- [37] 讨论了流处理中的时间语义:
	- 处理时间: 事件被处理的时间
	- 事件事件: 事件发生的时间, 无关传输延迟与处理延迟

- [41] 流处理系统很关键的一点: 能提供某些机制来处理 那些可能晚于水位线的迟到事件, 例如: 
	- 直接忽略
	- 将迟到事件写入日志
	- 利用迟到事件数据 修正之前的结果

- [42] 讨论了流处理中的状态处理的难点: 
	- 状态管理: 系统要高效地管理状态, 并保证它们不受并发更新的影响
	- 状态划分: 把状态按键值划分, 并独立管理每部分, 来解决状态的并行化处理的问题
	- 状态恢复: 从故障中恢复状态

- 第二章, 讨论流处理模型的维度
	- 时间语义
	- 状态处理 -> 故障处理
	- 一致性模型 -> 结果保障
		- 最多一次
		- 最少一次
		- 精确一次
		- 端到端的精确一次

- [65] 状态管理: Flink有两类状态量
	- 算子状态: 在同一个并行任务内的记录, 都能访问到相同的状态
	- 键值分区状态: 按输入记录所定义的键值 进行分区. 所有键值相同的记录都能访问到一样的状态

- [68] 有状态的算子的扩缩容, 与分布式数据库的重分区方法类似

- [74] Flink的检查点和恢复机制, 仅能重置 流式应用内部的状态, 不包括已经发往下游系统的记录信息

- [75] Flink检查点保存的数据包括: 数据原点位 + 算子状态
	- 检查点算法类似于毒丸算法 (有图解): 
		- Job Manager 通知所有数据源产生毒丸
		- 数据源 向所有算子传播毒丸
		- 算子接收到所有数据源的毒丸, 开始保存状态

- [79] Flink将状态的复制工作完全交给 状态后端, 如RocksDB, 性能取决于后端的实现方法

- [80] 保存点 是由用户显式触发的, 与检查点相比, 还包含一些额外元数据
	- 检查点 用于故障恢复, 而保存点提供了更多的可能: 
		- 启动一个不同的但兼容的应用, 可用于修复应用的逻辑BUG
		- 用不同的并行度启动应用, 用于应用的扩缩容
		- 在另一个集群启动相同应用, 迁移应用到新的Flink, 或另一个数据中心
		- 暂停/继续 应用

- [97] 转换操作分为四类
	- 作用于 单个事件的基本转换
	- 针对 相同键值事件的KeyedStream转换 (将普通流 通过KeyBy操作 转化为 KeyedSteam)
	- 将多条数据流 合并为 一条, 或将一条拆分为多条
	- 对流中的事件 进行重新组织的分发转换

- [111] 算子的并行度, 默认设置为 应用配置值, 可单个算子进行调节

- [128] Flink在创建窗口 (窗口函数处理的数据窗口)时, 所使用的的时钟类型: 
	- process time: 处理算子的机器的时钟
	- event time: 数据自身包含的时间信息
	- ingestion time: 摄入时间, 事件进入处理引擎的时间. 代价与 event time一样, 意义不大

- [133] 水位线可用于平衡 延迟和结果完整性
	- 如果水位线过于宽松, (水位线 远落后于 已处理记录的时间戳), 那么产生的结果延迟会很大
	- 如果水位线过于紧迫, 会导致结果不完整 (迟到的数据过多)

- [134] 前面介绍的都是 Data Stream API, 无法访问时间信息和水位线. Flink提供了一组底层函数: 处理函数

- [170] 对迟到数据的处理: 
	- 丢弃
	- 将迟到事件 重定向到 单独的数据流
	- 根据迟到事件 更新并发出计算结果

- [172] 基于迟到数据更新结果
	- 可指定一个 延迟容忍度 的额外时间段, 当窗口数据过期后, 但仍在容忍度内, 会已经处理过的窗口, 用于迟到数据的更新

- [210] 为了在应用中实现精确一次的状态一致性, 应用都需要支持 将读取位置重置为已有检查点 (允许读取位置回溯)

- [211] 有两种技术用于实现 精确一次保障
	- 幂等性写
	- 事务性写: 到检查点 才能提交数据到外存储

- [213] Flink 提供了丰富的 数据源 和 数据汇 的连接器
